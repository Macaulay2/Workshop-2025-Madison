symmetricGroup = method()
symmetricGroup ZZ := List => n -> (
    if n < 1 then error("invalid matrix size");
	for sigma in permutations toList(1..n) list permutation sigma
    )


-- given a polytope P and a matrix M or list of matrices L
-- check that P is invariant under M or under each matrix in L
isSymmetric = method()
isSymmetric(Polyhedron, Matrix) := Boolean => (P, M) -> (
    V := sort vertices P; -- vertices of P are probably already sorted
    if numColumns M != numRows M then error("matrix must be square");
    if numColumns M != numRows V then error("matrix incompatible with polytope");
    MV := sort M * V;
    if ring MV =!= ring V then error("rings of matrices are different");
    MV == V
    )

-- isSymmetric(Polyhedron, Matrix) := Boolean => (P, M) -> (
--     if numColumns M != numRows M then error("matrix must be square");
-- 	V := vertices P;
--     if numColumns M != numRows V then error("matrix incompatible with polytope");
-- 	V' := set entries transpose V;
	
-- 	MV := M * V;
-- 	isSubset(V', set entries transpose MV)
-- 	)

isSymmetric(Polyhedron, List) := Boolean => (P, L) -> (
    result := true;
    for M in L do if not isSymmetric(P, M) then (result = false; break);
    result
    )

-- would need this to compute conjugacy classes

-- group generated by a list of matrices
-- the user should guarantee that the group they generate is finite
generateGroup = method(
    Options => {
	Verbose => false
	}
    )
generateGroup List := List => opts -> L -> (
    local g;
    local h;
    local gh;
    -- construct a Cayley table of the group
    countMults := 0;
    groupElements := new MutableHashTable from for M in L list M => true;
    multsToCheck := new MutableList from flatten for i from 0 to #L-1 list for j from 0 to i list (L_i, L_j);
    while #multsToCheck > 0 do (
			-- pop one mult
		(g, h) = remove(multsToCheck, -1);
		gh = g * h;
		countMults = countMults +1;
		if not groupElements#?gh then (
			groupElements#gh = true;
			for f in keys groupElements do multsToCheck##multsToCheck = (gh, f);
			-- note that gh*gh is not necessary to add because we will get to it eventually by gh*g*h
			if opts.Verbose then (
			print("found element: " | net gh | " (total elements: " | toString(#groupElements) | ")");
			);
			);
		if opts.Verbose then (
			print("-- remains to check " | toString (#multsToCheck) | " multiplicaions");
			);
		);
    if opts.Verbose then (
	print("-- completed in " | toString countMults | " multiplications");
	);
    keys groupElements  -- returns list of matrices
    )


-- conjugacy classes takes a list of matrices, which is a group,
-- and returns a list of list of elements belonging to conugacy classes

conjugacyClasses = method(
    Options => {
	Verbose => false,
	OnlyListRepresentatives => false
	}
    )
conjugacyClasses List := List => opts -> G -> (
    numConjugations := 0;
    isClassified := new MutableHashTable from for g in G list g => false;
    result := for g in G list (
	if isClassified#g then continue else (
	    if opts.Verbose then (
		print("new class: " | net g);
		print("");
		);
	    isClassified#g = true;
	    conjClass := new MutableHashTable from {g => true};
	    for h in G do (
		hgh := h * g * h^(-1);
		numConjugations = numConjugations + 1;
		if not conjClass#?hgh then (isClassified#hgh = true; conjClass#hgh = true);
		);
	    if opts.OnlyListRepresentatives then g else keys conjClass
	    )
	);
    if opts.Verbose then (
	print("-- completed in " | toString numConjugations | " conjugations");
	);
    result
    )


-- replace the following with permutation [Partition type]

-- takes a partition L of n and returns a permutation
-- with cycle type L
partitionToPermutation = method()
partitionToPermutation List := List => L -> (
    cycleStart := 0;
    flatten for cycleLength in L list (
		cycleStart = cycleStart + cycleLength;
		for i from cycleStart - cycleLength to cycleStart -1 list (
			if i == cycleStart -1 then cycleStart - cycleLength else i + 1
			)
		)
    )

-- get conjugacy class reps for Sn
-- living as n x n permutation matrices

-- maybe rename to cycleTypeRepresentatives ? [ask Ollie]
-- snConjugacyClassReps = method()
-- snConjugacyClassReps ZZ := n -> (
cycleTypeRepresentatives = method()
cycleTypeRepresentatives ZZ := List => n -> (
    S := toList \ partitions n;
    for s in S list matrix partitionToPermutation s
    )


-- return the subset of points of P that are fixed by g
fixedPolytope = method()
fixedPolytope(Polyhedron, Matrix) := Polyhedron => (P, g) -> (
    n := numRows vertices P;
    if numRows g != numColumns g or numRows g != n then error("matrix size mismatch");
    gFixedSpace := coneFromHData(map(ZZ^0, ZZ^n, 0), g - id_(ZZ^n));
    intersection(P, gFixedSpace)
    )



-- could add these two to Polyhedra

-- hypersimplex
-- hypersimplex = method()
-- hypersimplex(ZZ, ZZ) := (n, k) -> (
--     convexHull transpose matrix for s in subsets(n, k) list (
-- 	for i from 0 to n-1 list if member(i, s) then 1 else 0
-- 	)
--     )

-- permutohedron = method()
-- permutohedron ZZ := n -> (
--     convexHull transpose matrix permutations n
--     )



-- representation ring of Sn over QQ
-- order of the rows and cols of character table
-- is given by 'partitions n'
representationRing = method(Options => {ReturnTable => false})
representationRing ZZ := opts -> n -> (
    a := getSymbol "a";
    x := getSymbol "x";
    R := QQ[a_1 .. a_n];
    T := symmetricGroupTable R;
    M := sub(T.table, QQ);
    -- N := inverse transpose M;
    -- m := numRows M;
	m := numColumns M;
    S := QQ[x_1 .. x_m];
    -*
    X := matrix {gens S};
    I := ideal flatten for i from 0 to m-1 list for j from 0 to i list (
	-- product of rows i and j in M
	S_i * S_j - (X * N * transpose matrix {for k from 0 to m-1 list M_(i, k) * M_(j, k)})_(0,0)
	);
    if opts.ReturnTable then (S/I, T) else S/I
    *-
    if opts.ReturnTable then (S, M) else S
    )


-- EES of a polytope invariant under Sn
equivariantEhrhartSeries = method(
    Options => {
	ReturnTable => true,
	ReturnPartitionList => true,
	ReturnHStarList => true
	})
equivariantEhrhartSeries Polyhedron := opts -> P -> (
		n := numRows vertices P;
		-- check P invariant under Sn
		g1 := matrix permutation rotate(1, toList(1..n));
		g2 := matrix extend(transposition 1, n);
		if not (isSymmetric(P, g1) and isSymmetric(P, g2)) then error("polytope is not Sn invariant");
		conjClassRepMats := cycleTypeRepresentatives n;
		fixedPolytopeList := (g -> fixedPolytope(P, g)) \ conjClassRepMats;
		(R, T) := repRing(n, ReturnTable => true);
		m := numgens R; -- equals number of conj classes
		Rt := R[getSymbol "t"];
		t := Rt_0;
		hStarList := (Pg -> hStar(Pg, Rt, ReturnDenominator => true)) \ fixedPolytopeList;
		ehrhartHStarList := for i from 0 to m-1 list (
				g := sub(conjClassRepMats_i, Rt);
				detRep := det(id_(Rt^n) - t*g);
				(hStarNum, hStarDenom) := hStarList_i;
				if not zero((hStarNum * detRep) % hStarDenom) then (
						print "bad symmetry:";
						print g;
						error("equivariant hStar not polynomial");
						);
				(hStarNum * detRep) // hStarDenom
				); -- list of Ehrhart H* polynomials note that denominator is det(I - tg)
		H := (matrix {ehrhartHStarList} * (inverse T) * transpose matrix {gens R})_(0,0);
		result := {H};
		if opts.ReturnTable then result = result | {T};
		if opts.ReturnPartitionList then result = result | {toList \ partitions n};
		if opts.ReturnHStarList then result = result | {ehrhartHStarList};
		result
		)


-- obit polytope under Sn
-- expects a single column matrix: a point in QQ^n
orbitPolytope = method()
orbitPolytope Matrix := Polyhedron => p -> (
    n := numRows p;
    if numColumns p != 1 then error("expected matrix with 1 column");
    V := map(QQ^n, QQ^0, 0);
    for g in (symmetricGroup n) / matrix do (
	V = V | g*p;
	);
    convexHull V
    )
